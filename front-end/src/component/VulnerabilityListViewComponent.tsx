import React from "react";
import VulnerabilityListItemComponent from "./VulnerabilityListItemComponent";
import { getVulnerabilitiesAction } from "../action/VulnerabilityAction";

import { connect, ConnectedProps } from "react-redux";
import { RootState } from "../store";

import "../css/VulnerabilityListViewComponent.css";
import sanitizeString from "../util/SanitizeString";
import SVGButton from "./SVGButton";

type ConstructorType = {
  loading: boolean;
  prevMax: number;
};

type PropsType = ConnectedProps<typeof connector>;

class VulnerabilityListViewComponent extends React.Component<
  PropsType,
  ConstructorType
> {
  private loadingRef: any;
  private itemRefs: any[];

  private observer: IntersectionObserver;

  constructor(props: PropsType) {
    super(props);
    this.state = {
      loading: false,
      prevMax: 0,
    };

    this.loadingRef = React.createRef();

    this.observer = new IntersectionObserver(this.checkScroll.bind(this), {
      root: null,
      rootMargin: "0%",
      threshold: 0.2,
    });

    this.itemRefs = [];

    this.itemRefs = this.props.vulnerabilities.map(() => {
      return React.createRef();
    });
  }
  componentDidMount() {
    //Set up an observer to watch loadingRef / trigger loading of more CVEs
    this.observer.observe(this.loadingRef);

    //Load initial CVEs
    if (
      this.props.vulnerabilities.length === 0 &&
      this.state.loading === false
    ) {
      this.setState({ loading: true });
      return this.props
        .getVulnerabilities(
          this.props.toggledFilters,
          this.props.toggledSubscriptions,
          this.props.vulnerabilities.length,
          this.props.pageSize
        )
        .then(() => {
          this.setState({ loading: false });
        })
        .catch((err: any) => {
          console.log(err);
        });
    }
  }

  componentWillUnmount() {
    this.setState = () => {
      return;
    };
  }

  /* Callback called by IntersectionObserver when scroll loading div is in viewport */
  checkScroll(entities: any[], observer: IntersectionObserver) {
    //TODO: Add a bypass if all of the records have been retrieved already (maxForFilter is reached)
    let yPos = entities[0].boundingClientRect.y;

    if (
      this.state.prevMax > yPos &&
      this.props.vulnerabilities.length > 0 &&
      !this.state.loading
    ) {
      this.setState({ loading: true });
      return this.props
        .getVulnerabilities(
          this.props.toggledFilters,
          this.props.toggledSubscriptions,
          this.props.vulnerabilities.length,
          this.props.pageSize
        )
        .then(() => {
          this.setState({ loading: false });
        })
        .catch((err: Error) => {
          console.log(err);
        });
    }

    this.setState({ prevMax: yPos });
  }

  /* Handles changing view to focus on specific CVE cards */
  handleClickItem(ref: any) {
    ref.scrollIntoView({
      behavior: "smooth",
      block: "start",
      inline: "nearest",
    });
  }

  render(): any {
    let vulnerabilities = [] as any[];

    if (this.props.vulnerabilities !== undefined) {
      vulnerabilities = this.props.vulnerabilities.map(
        (it: any, index: number) => {
          return (
            <VulnerabilityListItemComponent
              key={"vulnerability-list-item-" + index}
              data={it}
              inputRef={(r: any) => {
                this.itemRefs[index] = r;
              }}
              onClick={() => {
                this.handleClickItem(this.itemRefs[index]);
              }}
            />
          );
        }
      );
    }

    return (
      <div className="vulnerability-list">
        <div className="vulnerability-list-content">
          {vulnerabilities}
          <SVGButton
            className={
              this.state.loading
                ? "vulnerability-loading-indicator-on"
                : "vulnerability-loading-indicator-off"
            }
            type={9}
            stroke={"currentColor"}
            viewBox={"0 0 24 24"}
            hoverText={"Searching for vulnerabilities, please wait..."}
          />
          <div
            ref={(loadingRef) => (this.loadingRef = loadingRef)}
            className="vuln-list-scroll-space"
          >
            {" "}
          </div>
        </div>
      </div>
    );
  }
}

function mapStateToProps(state: RootState) {
  return {
    vulnerabilities: state.vulnerabilityReducer.vulnerabilities,
    toggledFilters: state.filterReducer.toggledFilters,
    toggledSubscriptions: state.accountReducer.toggledSubscriptions,
    pageSize: state.settingsReducer.pageSize,
    session: state.accountReducer.hasSession,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    getVulnerabilities: (
      query: string[],
      subscriptions: string[],
      startAt: number,
      pageSize: number
    ) => {
      let terms = "";

      //TODO: Remove duplicate terms
      let allTerms = [...query, ...subscriptions];

      if (allTerms.length > 0) {
        terms = allTerms.reduce((val, it) => {
          return val + "+" + sanitizeString(it);
        });
      }

      return dispatch(getVulnerabilitiesAction(terms, startAt, pageSize));
    },
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(VulnerabilityListViewComponent);
