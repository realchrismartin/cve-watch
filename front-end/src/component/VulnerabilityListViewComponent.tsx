import React from "react";
import VulnerabilityListItemComponent from "./VulnerabilityListItemComponent";
import {
  getVulnerabilitiesAction,
} from "../action/VulnerabilityAction"

import { connect, ConnectedProps } from "react-redux";
import { RootState } from "../store";

import "../css/VulnerabilityListViewComponent.css";
import sanitizeString from "../util/SanitizeString";

type ConstructorType = {
  loading: boolean;
  prevMax: number;
};

type PropsType = ConnectedProps<typeof connector>;

class VulnerabilityListViewComponent extends React.Component<
  PropsType,
  ConstructorType
> {
  private loadingRef: any;
  private itemRefs: any[];

  private observer: IntersectionObserver;

  constructor(props: PropsType) {
    super(props);
    this.state = {
      loading: false,
      prevMax: 0,
    };

    this.loadingRef = React.createRef();

    this.observer = new IntersectionObserver(this.checkScroll.bind(this), {
      root: null,
      rootMargin: "0%",
      threshold: 0.2,
    });

    this.itemRefs = [];

    this.itemRefs = this.props.vulnerabilities.map(() => {
      return React.createRef();
    });
  }
  componentDidMount() {
    //Set up an observer to watch loadingRef / trigger loading of more CVEs
    this.observer.observe(this.loadingRef);

    //Load initial CVEs
    if (
      this.props.vulnerabilities.length === 0 &&
      this.state.loading === false
    ) {
      this.setState({ loading: true });
      return this.props
        .getVulnerabilities(
          this.props.toggledFilters,
          this.props.toggledSubscriptions,
          this.props.vulnerabilities.length,
          this.props.pageSize
        )
        .then(() => {
          this.setState({ loading: false });
        })
        .catch((err: any) => {
          console.log(err);
        });
    }
  }

  componentWillUnmount() {
    this.setState = () =>{ return;};
  }

  /* Callback called by IntersectionObserver when scroll loading div is in viewport */
  checkScroll(entities: any[], observer: IntersectionObserver) {
    //TODO: Add a bypass if all of the records have been retrieved already (maxForFilter is reached)
    let yPos = entities[0].boundingClientRect.y;

    if (
      this.state.prevMax > yPos &&
      this.props.vulnerabilities.length > 0 &&
      !this.state.loading
    ) {
      this.setState({ loading: true });
      return this.props
        .getVulnerabilities(
          this.props.toggledFilters,
          this.props.toggledSubscriptions,
          this.props.vulnerabilities.length,
          this.props.pageSize
        )
        .then(() => {
          this.setState({ loading: false });
        })
        .catch((err: Error) => {
          console.log(err);
        });
    }

    this.setState({ prevMax: yPos });
  }

  /* Handles changing view to focus on specific CVE cards */
  handleClickItem(ref: any) {
    ref.scrollIntoView({behavior: "smooth", block: "start", inline: "nearest"});
  }

  render(): any {
    let vulnerabilities = [] as any[];

    if (this.props.vulnerabilities !== undefined) {
      vulnerabilities = this.props.vulnerabilities.map(
        (it: any, index: number) => {
          return (
            <VulnerabilityListItemComponent
              key={"vulnerability-list-item-" + index}
              data={it}
              inputRef={(r: any) => {
                this.itemRefs[index] = r;
              }}
              onClick={() => {
                this.handleClickItem(this.itemRefs[index]);
              }}
            />
          );
        }
      );
    }

    return (
      <div className="vulnerability-list">
        <div className="vuln-loading-container">
        <svg
          className={
            this.state.loading
              ? "vuln-loading-indicator-on"
              : "vuln-loading-indicator-off"
          }
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 25 25"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
          />
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
          />
        </svg>
      </div>
        <div className="vulnerability-list-content">
          {vulnerabilities}
          <div
            ref={(loadingRef) => (this.loadingRef = loadingRef)}
            className="vuln-list-scroll-space"
          >
            {" "}
          </div>
        </div>
      </div>
    );
  }
}

function mapStateToProps(state: RootState) {
  return {
    vulnerabilities: state.vulnerabilityReducer.vulnerabilities,
    toggledFilters: state.filterReducer.toggledFilters,
    toggledSubscriptions: state.accountReducer.toggledSubscriptions,
    pageSize: state.settingsReducer.pageSize,
    session: state.accountReducer.hasSession,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    getVulnerabilities: (
      query: string[],
      subscriptions: string[],
      startAt: number,
      pageSize: number
    ) => {
      let terms = "";

      //TODO: Remove duplicate terms
      let allTerms = [...query, ...subscriptions];

      if (allTerms.length > 0) {
        terms = allTerms.reduce((val, it) => {
          return val + "+" + sanitizeString(it);
        });
      }

      return dispatch(getVulnerabilitiesAction(terms, startAt, pageSize));
    }
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(VulnerabilityListViewComponent);
