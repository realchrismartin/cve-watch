import React from "react";
import { RootState } from "../store";
import { ConnectedProps, connect } from "react-redux";
import { debounce } from "lodash";
import {
  clearSoftwareAction,
  getCPESoftwareAction,
  getRepoSoftwareAction,
  setSoftwareQueryAction,
} from "../action/SoftwareAction";

import "../css/SoftwareSearchViewComponent.css";
import SoftwareSearchListItemComponent from "./SoftwareSearchListItemComponent";

type ConstructorType = {
  loading: boolean;
  queryMinLength: number;
  queryDebounceTimeout: number;
  pageSize: number;
  prevMax: number;
};
type PropsType = ConnectedProps<typeof connector>;

class SoftwareSearchViewComponent extends React.Component<
  PropsType,
  ConstructorType
> {
  private loadingRef: any;
  private searchInputRef: any;
  private githubRepoURLRegex: RegExp;

  private observer: IntersectionObserver;
  private handleQueryChangeDebounced: any;

  constructor(props: PropsType) {
    super(props);

    this.state = {
      loading: false,
      queryMinLength: 4,
      queryDebounceTimeout: 2000,
      pageSize: 100,
      prevMax: 0,
    };

    this.loadingRef = React.createRef();
    this.searchInputRef = React.createRef();

    this.observer = new IntersectionObserver(this.checkScroll.bind(this), {
      root: null,
      rootMargin: "0%",
      threshold: 0.2,
    });

    this.handleQueryChange = this.handleQueryChange.bind(this);
    this.handleQueryChangeDebounced = debounce(() => {
      this.handleQueryChange();
    }, this.state.queryDebounceTimeout);

    this.githubRepoURLRegex = new RegExp(
      /^(https{0,1}:\/\/)(api){0,1}github.com\/(.*?)\/(.*?)$/
    );
  }

  componentDidMount() {
    //Set up an observer to watch loadingRef / trigger loading of more CPEs
    this.observer.observe(this.loadingRef);
  }

  /* Handles executing a query if the query string has changed */
  handleQueryChange() {
    let query = this.searchInputRef.value;

    this.props.clearSoftware().then(() => {
      this.props.setSoftwareQuery(query).then(() => {
        this.setState({ loading: true });

        let isQueryRepo = query.match(this.githubRepoURLRegex);

        if (isQueryRepo) {
          this.props
            .getRepoSoftware(
              isQueryRepo[3],
              isQueryRepo[4],
              this.props.software.length,
              this.state.pageSize
            )
            .then(() => {
              this.setState({ loading: false });
            })
            .catch((err: Error) => {
              console.log(err);
            });
        } else {
          this.props
            .getCPESoftware(
              this.props.query,
              this.props.software.length,
              this.state.pageSize
            )
            .then(() => {
              this.setState({ loading: false });
            })
            .catch((err: Error) => {
              console.log(err);
            });
        }
      });
    });
  }

  /* Callback called by IntersectionObserver when scroll loading div is in viewport */
  checkScroll(entities: any[], observer: IntersectionObserver) {
    //TODO: Add a bypass if all of the records have been retrieved already (maxForFilter is reached)
    let yPos = entities[0].boundingClientRect.y;

    if (
      this.state.prevMax > yPos &&
      this.props.software.length > 0 &&
      !this.state.loading
    ) {
      this.setState({ loading: true });

      let isQueryRepo = this.props.query.match(this.githubRepoURLRegex);

      if (isQueryRepo) {
        this.props
          .getRepoSoftware(
            isQueryRepo[3],
            isQueryRepo[4],
            this.props.software.length,
            this.state.pageSize
          )
          .then(() => {
            this.setState({ loading: false });
          })
          .catch((err: Error) => {
            console.log(err);
          });
      } else {
        return this.props
          .getCPESoftware(
            this.props.query,
            this.props.software.length,
            this.state.pageSize
          )
          .then(() => {
            this.setState({ loading: false });
          })
          .catch((err: Error) => {
            console.log(err);
          });
      }
    }

    this.setState({ prevMax: yPos });
  }
  render(): any {
    let softwareListItems = [];

    if (this.props.software !== undefined) {
      softwareListItems = this.props.software.map((it: any, index: number) => {
        return (
          <SoftwareSearchListItemComponent
            key={"software-list-item-" + index}
            data={it}
          />
        );
      });
    }

    return (
      <div>
        <div>
          <div className="software-search-bar">
          <div className="software-search-bar-icon">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 25 25"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M8 16l2.879-2.879m0 0a3 3 0 104.243-4.242 3 3 0 00-4.243 4.242zM21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
          </div>
            <form
              onSubmit={(e) => {
                e.preventDefault();
                this.handleQueryChangeDebounced();
              }}
            >
              <input
                id="softwareSearchQueryInput"
                ref={(inputRef) => (this.searchInputRef = inputRef)}
                minLength={this.state.queryMinLength}
                disabled={this.state.loading}
              />
              <button
                onClick={(e) => {
                  this.handleQueryChangeDebounced();
                }}
              >
                Search
              </button>

            </form>
          </div>
          <svg
                className={
                  this.state.loading
                    ? "software-loading-indicator-on"
                    : "software-loading-indicator-off"
                }
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 25 25"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
                />
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                />
              </svg>
        </div>
        <div className="software-list">
          {softwareListItems}
          <div
            ref={(loadingRef) => (this.loadingRef = loadingRef)}
            className="software-search-scroll-space"
          >
            {" "}
          </div>
        </div>
      </div>
    );
  }
}

function mapStateToProps(state: RootState) {
  return {
    account: state.accountReducer.account,
    software: state.softwareReducer.software,
    query: state.softwareReducer.query,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    getCPESoftware: (query: string, startAt: number, pageSize: number) => {
      return dispatch(getCPESoftwareAction(query, startAt, pageSize));
    },

    getRepoSoftware: (
      user: string,
      repo: string,
      startAt: number,
      pageSize: number
    ) => {
      return dispatch(getRepoSoftwareAction(user, repo, startAt, pageSize));
    },
    clearSoftware: () => {
      return dispatch(clearSoftwareAction());
    },
    setSoftwareQuery: (query: string) => {
      return dispatch(setSoftwareQueryAction(query));
    },
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(SoftwareSearchViewComponent);
