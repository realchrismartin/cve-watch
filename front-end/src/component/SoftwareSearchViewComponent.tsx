import React from "react";
import { RootState } from "../store";
import { ConnectedProps, connect } from "react-redux";
import { debounce } from "lodash";
import {
  clearSoftwareAction,
  getCPESoftwareAction,
  getRepoSoftwareAction,
  setSoftwareQueryAction,
} from "../action/SoftwareAction";

import "../css/SoftwareSearchViewComponent.css";
import SoftwareSearchListItemComponent from "./SoftwareSearchListItemComponent";

type ConstructorType = {
  loading: boolean;
  queryMinLength: number;
  queryDebounceTimeout: number;
  pageSize: number;
  prevMax: number;
};
type PropsType = ConnectedProps<typeof connector>;

class SoftwareSearchViewComponent extends React.Component<
  PropsType,
  ConstructorType
> {
  private loadingRef: any;
  private searchInputRef: any;
  private githubRepoURLRegex: RegExp;

  private observer: IntersectionObserver;
  private handleQueryChangeDebounced: any;

  constructor(props: PropsType) {
    super(props);

    this.state = {
      loading: false,
      queryMinLength: 4,
      queryDebounceTimeout: 2000,
      pageSize: 100,
      prevMax: 0,
    };

    this.loadingRef = React.createRef();
    this.searchInputRef = React.createRef();

    this.observer = new IntersectionObserver(this.checkScroll.bind(this), {
      root: null,
      rootMargin: "0%",
      threshold: 0.2,
    });

    this.handleQueryChange = this.handleQueryChange.bind(this);
    this.handleQueryChangeDebounced = debounce(() => {
      this.handleQueryChange();
    }, this.state.queryDebounceTimeout);

    this.githubRepoURLRegex = new RegExp(
      /^(https{0,1}:\/\/)(api){0,1}github.com\/(.*?)\/(.*?)$/
    );
  }

  componentDidMount() {
    //Set up an observer to watch loadingRef / trigger loading of more CPEs
    this.observer.observe(this.loadingRef);
  }

  /* Handles executing a query if the query string has changed */
  handleQueryChange() {
    let query = this.searchInputRef.value;

    this.props.clearSoftware().then(() => {
      this.props.setSoftwareQuery(query).then(() => {
        let isQueryRepo = query.match(this.githubRepoURLRegex);

        if (isQueryRepo) {
          this.props
            .getRepoSoftware(
              isQueryRepo[3],
              isQueryRepo[4],
              this.props.software.length,
              this.state.pageSize
            )
            .then(() => {
              this.setState({ loading: false });
            })
            .catch((err: Error) => {
              console.log(err);
            });
        } else {
          this.props
            .getCPESoftware(
              this.props.query,
              this.props.software.length,
              this.state.pageSize
            )
            .then(() => {
              this.setState({ loading: false });
            })
            .catch((err: Error) => {
              console.log(err);
            });
        }
      });
    });
  }

  /* Callback called by IntersectionObserver when scroll loading div is in viewport */
  checkScroll(entities: any[], observer: IntersectionObserver) {
    //TODO: Add a bypass if all of the records have been retrieved already (maxForFilter is reached)
    let yPos = entities[0].boundingClientRect.y;

    if (
      this.state.prevMax > yPos &&
      this.props.software.length > 0 &&
      !this.state.loading
    ) {
      this.setState({ loading: true });

      let isQueryRepo = this.props.query.match(this.githubRepoURLRegex);

      if (isQueryRepo) {
        this.props
          .getRepoSoftware(
            isQueryRepo[3],
            isQueryRepo[4],
            this.props.software.length,
            this.state.pageSize
          )
          .then(() => {
            this.setState({ loading: false });
          })
          .catch((err: Error) => {
            console.log(err);
          });
      } else {
        return this.props
          .getCPESoftware(
            this.props.query,
            this.props.software.length,
            this.state.pageSize
          )
          .then(() => {
            this.setState({ loading: false });
          })
          .catch((err: Error) => {
            console.log(err);
          });
      }
    }

    this.setState({ prevMax: yPos });
  }
  render(): any {
    let softwareListItems = [];

    if (this.props.software !== undefined) {
      softwareListItems = this.props.software.map((it: any, index: number) => {
        return (
          <SoftwareSearchListItemComponent
            key={"software-list-item-" + index}
            data={it}
          />
        );
      });
    }

    return (
      <div>
        <div className="software-search-bar">
          <form
            onSubmit={(e) => {
              e.preventDefault();
            }}
          >
            <input
              id="softwareSearchQueryInput"
              ref={(inputRef) => (this.searchInputRef = inputRef)}
              minLength={this.state.queryMinLength}
              disabled={this.state.loading}
              onChange={() => {
                this.handleQueryChangeDebounced();
              }}
            />
          </form>
        </div>
        <div className="software-list">
          {softwareListItems}
          <div
            ref={(loadingRef) => (this.loadingRef = loadingRef)}
            className="software-search-scroll-space"
          >
            {" "}
          </div>
        </div>
      </div>
    );
  }
}

function mapStateToProps(state: RootState) {
  return {
    account: state.accountReducer.account,
    software: state.softwareReducer.software,
    query: state.softwareReducer.query,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    getCPESoftware: (query: string, startAt: number, pageSize: number) => {
      return dispatch(getCPESoftwareAction(query, startAt, pageSize));
    },

    getRepoSoftware: (
      user: string,
      repo: string,
      startAt: number,
      pageSize: number
    ) => {
      return dispatch(getRepoSoftwareAction(user, repo, startAt, pageSize));
    },
    clearSoftware: () => {
      return dispatch(clearSoftwareAction());
    },
    setSoftwareQuery: (query: string) => {
      return dispatch(setSoftwareQueryAction(query));
    },
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(SoftwareSearchViewComponent);
