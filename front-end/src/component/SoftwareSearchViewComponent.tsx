import React from "react";
import { RootState } from "../store";
import { ConnectedProps, connect } from "react-redux";
import { debounce } from "lodash";
import {
  clearSoftwareAction,
  getSoftwareAction,
  setSoftwareQueryAction,
} from "../action/SoftwareAction";

import "../css/SoftwareSearchViewComponent.css";

type ConstructorType = {
  loading: boolean;
  queryMinLength: number;
  queryDebounceTimeout: number;
  pageSize: number;
  prevMax: number;
};
type PropsType = ConnectedProps<typeof connector>;

class SoftwareSearchViewComponent extends React.Component<
  PropsType,
  ConstructorType
> {
  private loadingRef: any;
  private searchInputRef: any;

  private observer: IntersectionObserver;
  private handleQueryChangeDebounced: any;

  constructor(props: PropsType) {
    super(props);

    this.state = {
      loading: false,
      queryMinLength: 4,
      queryDebounceTimeout: 2000,
      pageSize: 100,
      prevMax: 0,
    };

    this.loadingRef = React.createRef();
    this.searchInputRef = React.createRef();

    this.observer = new IntersectionObserver(this.checkScroll.bind(this), {
      root: null,
      rootMargin: "0%",
      threshold: 0.2,
    });

    this.handleQueryChange = this.handleQueryChange.bind(this);
    this.handleQueryChangeDebounced = debounce(() => {
      this.handleQueryChange();
    }, this.state.queryDebounceTimeout);
  }

  componentDidMount() {
    //Set up an observer to watch loadingRef / trigger loading of more CPEs
    this.observer.observe(this.loadingRef);
  }

  /* Handles executing a query if the query string has changed */
  handleQueryChange() {
    //TODO
    this.searchInputRef.value = ""; //Clear value when query complete
  }

  /* Callback called by IntersectionObserver when scroll loading div is in viewport */
  checkScroll(entities: any[], observer: IntersectionObserver) {
    //TODO: Add a bypass if all of the records have been retrieved already (maxForFilter is reached)
    let yPos = entities[0].boundingClientRect.y;

    if (
      this.state.prevMax > yPos &&
      this.props.software.length > 0 &&
      !this.state.loading
    ) {
      this.setState({ loading: true });
      return this.props
        .getSoftware(
          this.props.software.query,
          this.props.software.length,
          this.state.pageSize
        )
        .then(() => {
          this.setState({ loading: false });
        })
        .catch((err: Error) => {
          console.log(err);
        });
    }

    this.setState({ prevMax: yPos });
  }
  render(): any {
    return (
      <div>
        <div className="software-search-bar">
            <form
              onSubmit={(e) => {
                e.preventDefault();
              }}
            >
              <input
                id="softwareSearchQueryInput"
                ref={(inputRef) => (this.searchInputRef = inputRef)}
                minLength={this.state.queryMinLength}
                disabled={this.state.loading}
                onChange={() => {
                  this.handleQueryChangeDebounced();
                }}
              />
            </form>
          </div>
        <div
          ref={(loadingRef) => (this.loadingRef = loadingRef)}
          className="software-search-scroll-space"
        >
          {" "}
        </div>
      </div>
    );
  }
}

function mapStateToProps(state: RootState) {
  return {
    account: state.accountReducer.account,
    software: state.softwareReducer.software,
    query: state.softwareReducer.query,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    getSoftware: (query: string, startAt: number, pageSize: number) => {
      return dispatch(getSoftwareAction(query, startAt, pageSize));
    },
    clearSoftware: () => {
      return dispatch(clearSoftwareAction());
    },
    setSoftwareQuery: (query : string) => {
      return dispatch(setSoftwareQueryAction(query));
    }
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(SoftwareSearchViewComponent);
