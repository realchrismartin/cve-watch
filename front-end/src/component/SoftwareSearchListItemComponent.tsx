import React from "react";
import { connect, ConnectedProps } from "react-redux";
import { RootState } from "../store";
import "../css/SoftwareSearchListItemComponent.css";
import {
  subscribeToSoftwareAction,
  toggleSubscriptionOffAction,
  toggleSubscriptionOnAction,
  unsubscribeFromSoftwareAction,
} from "../action/AccountAction";
import SVGButton from "./SVGButton";
import sanitizeString from "../util/SanitizeString";
import { 
  clearVulnerabilitiesAction, 
  getVulnerabilitiesAction,
} from "../action/VulnerabilityAction";

type OwnProps = { data: any; simple: boolean; cpeURI? : string };
type PropsType = ConnectedProps<typeof connector> & OwnProps;
type ComponentType = {};

/* Represents a software or dependency that can be subscribed to */
/* Input data can be either a CPE record or a simple string */
class SoftwareSearchListItemComponent extends React.Component<
  PropsType,
  ComponentType
> {

  private title : string;
  private cpeURI : string;

  constructor(props : PropsType) {
    super(props);

    this.title = this.props.data;
    this.cpeURI = this.props.data;

    try {
      this.title = this.props.data;
      this.title = this.props.data["titles"][0]["title"];
      this.title = this.title.split(" ")[0];
    } catch (err) {}
    try {
      this.cpeURI = this.props.data; 
      this.cpeURI = this.props.data["cpe23Uri"];
    } catch (err) {}

    if(this.props.cpeURI) {
      this.cpeURI = this.props.cpeURI;
    }

  }

  handleSubscribe(subscribe: boolean) {

    let subscription = this.cpeURI || this.title;

    subscription = sanitizeString(subscription);

    if (subscribe) {
      this.props.subscribeTo(subscription, this.props.subscriptions, 0, this.props.pageSize)
      .catch((err: any) => {
        console.log(err);
      });
    } else {
      this.props.unsubscribeFrom(subscription).catch((err: any) => {
        console.log(err);
      });
    }
  }

  render() {
    let subscribedTitle = this.props.subscriptions.indexOf(this.title);
    let subscribedCPE = this.props.subscriptions.indexOf(this.cpeURI);

    let button = (<div></div>);

    let watchButton = (
        <SVGButton
        type={subscribedTitle > -1 || subscribedCPE > -1 ? 6 : 5}
        stroke={"currentColor"}
        fill={"none"}
        hoverText={(subscribedTitle > -1 || subscribedCPE > -1 ? "Unwatch" : "Watch") + " this software"}
        viewBox={"0 0 24 24"}
          onClick={() => {
            this.handleSubscribe(subscribedTitle > -1 || subscribedCPE > -1 ? false : true);
          }}
        />);

    if (this.props.session) {
      button = watchButton;
    }

    let simpleContent = (
      <span>
        <span className="software-search-list-item-subscribe-button">
          {button}
        </span>
        <span>{this.title}</span>
      </span>
    );

    let complexContent = (
      <div>
        <div className="software-search-list-item-subscribe-button">
          {button}
        </div>
        <div>{this.title}</div>
        <div>{this.cpeURI}</div>
      </div>
    );

    let content = this.props.simple ? simpleContent : complexContent;

    let className = this.props.simple
      ? "software-search-list-item software-search-list-item-simple"
      : "software-search-list-item software-search-list-item-complex";

    return <div className={className}>{content}</div>;
  }
}

function mapStateToProps(state: RootState) {
  return {
    subscriptions: state.accountReducer.subscriptions,
    toggledFilters: state.filterReducer.toggledFilters,
    session: state.accountReducer.hasSession,
    pageSize: state.settingsReducer.pageSize,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    subscribeTo: async (
      subscription: string, 
      allSubs: string[],
      startAt: number,
      pageSize: number) => {

      dispatch(await subscribeToSoftwareAction(subscription));
      dispatch(toggleSubscriptionOnAction(subscription));
      dispatch(clearVulnerabilitiesAction());
      let terms = "";
        if (allSubs.length > 0) {
          terms = allSubs.reduce((val, it) => {
            return val + "+" + it;
          });
        }
      return dispatch(getVulnerabilitiesAction(terms, startAt, pageSize));
      },

    unsubscribeFrom(subscription: string) {
      dispatch(toggleSubscriptionOffAction(subscription));
      return dispatch(unsubscribeFromSoftwareAction(subscription));
    },
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(SoftwareSearchListItemComponent);
