import React from "react";
import { RootState } from "../store";
import { connect, ConnectedProps } from "react-redux";
import "../css/SoftwareControlsComponent.css";
import { debounce } from "lodash";
import {
  clearSoftwareAction,
  getCPESoftwareAction,
  getRepoSoftwareAction,
  setSoftwareQueryAction,
} from "../action/SoftwareAction";
import SVGButton from "./SVGButton";

type PropsType = ConnectedProps<typeof connector>;
type ConstructorType = {
  loading: boolean;
  queryMinLength: number;
  queryDebounceTimeout: number;
  prevMax: number;
};
class SoftwareControlsComponent extends React.Component<
  PropsType,
  ConstructorType
> {
  private searchInputRef: any;
  private githubRepoURLRegex: RegExp;

  private handleQueryChangeDebounced: any;

  constructor(props: PropsType) {
    super(props);

    this.state = {
      loading: false,
      queryMinLength: 3,
      queryDebounceTimeout: 1000,
      prevMax: 0,
    };
    this.githubRepoURLRegex = new RegExp(
      /^(https{0,1}:\/\/)(api){0,1}github.com\/(.*?)\/(.*?)$/
    );

    this.searchInputRef = React.createRef();

    this.handleQueryChange = this.handleQueryChange.bind(this);
    this.handleQueryChangeDebounced = debounce(() => {
      this.handleQueryChange();
    }, this.state.queryDebounceTimeout);
  }

  /* Handles executing a query if the query string has changed */
  handleQueryChange() {
    if (this.searchInputRef === null) {
      return;
    }

    let query = this.searchInputRef.value;

    if (query.length <= this.state.queryMinLength) {
      return;
    }

    this.setState({ loading: true });
    
    this.props.clearSoftware().then(() => {
      this.props.setSoftwareQuery(query).then(() => {

        let isQueryRepo = query.match(this.githubRepoURLRegex);

        if (isQueryRepo) {
          this.props
            .getRepoSoftware(
              isQueryRepo[3],
              isQueryRepo[4],
              this.props.software.length,
              this.props.pageSize
            )
            .then(() => {
              this.setState({ loading: false });
            })
            .catch((err: Error) => {
              console.log(err);
            });
        } else {
          this.props
            .getCPESoftware(
              this.props.query,
              this.props.software.length,
              this.props.pageSize
            )
            .then(() => {
              this.setState({ loading: false });
            })
            .catch((err: Error) => {
              console.log(err);
            });
        }
      });
    });
  }
  render() {
    return (
      <div className="software-controls">
        <form
          onSubmit={(e) => {
            e.preventDefault();
            this.handleQueryChangeDebounced();
          }}
        >
          <input
            ref={(inputRef) => (this.searchInputRef = inputRef)}
            minLength={this.state.queryMinLength}
            disabled={this.state.loading}
          />
        </form>
        <SVGButton
          type={8}
          onClick={() => {
            this.handleQueryChangeDebounced();
          }}
          stroke={"currentColor"}
          viewBox={"0 0 24 24"}
          hoverText={"Search for a keyword or https://github.com/repo/url"}
        />
      </div>
    );
  }
}
function mapStateToProps(state: RootState) {
  return {
    software: state.softwareReducer.software,
    query: state.softwareReducer.query,
    pageSize: state.settingsReducer.pageSize,
  };
}

function mapDispatchToProps(dispatch: any) {
  return {
    getCPESoftware: (query: string, startAt: number, pageSize: number) => {
      return dispatch(getCPESoftwareAction(query, startAt, pageSize));
    },

    getRepoSoftware: (
      user: string,
      repo: string,
      startAt: number,
      pageSize: number
    ) => {
      return dispatch(getRepoSoftwareAction(user, repo, startAt, pageSize));
    },
    clearSoftware: () => {
      return dispatch(clearSoftwareAction());
    },
    setSoftwareQuery: (query: string) => {
      return dispatch(setSoftwareQueryAction(query));
    },
  };
}

const connector = connect(mapStateToProps, mapDispatchToProps);
export default connector(SoftwareControlsComponent);
