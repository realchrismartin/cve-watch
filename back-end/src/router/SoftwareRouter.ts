import express from "express";
import AbstractRouter from "./AbstractRouter";
import IRouter from "./IRouter";
import mockCPEResult from "../../test/mockCPEResult";
import axios, { AxiosResponse } from "axios";
import IReqFileParser from "../parser/IReqFileParser";
import PythonReqFileParser from "../parser/PythonReqFileParser";
import NodeReqFileParser from "../parser/NodeReqFileParser";
import IDependency from "../parser/IDependency";
import { githubAuthToken, githubBaseURI, nvdBaseURI, requestSleepTime, useRealData } from "../Settings";
import delay from "delay";

/* Router for handling requests to search NVD / GitHub for software */
class SoftwareRouter extends AbstractRouter implements IRouter {
  parsers: Map<RegExp, IReqFileParser>;
  githubRequestParams: any;

  constructor(app: express.Application, route: string) {
    super(app, route);

    //Set up routes
    this.router.get("/", this.getSoftwareRoute);
    this.router.get("/fromRepo/:user/:repo", this.getSoftwareByRepoRoute);

    //Set up RegExp -> Parser mappings
    this.parsers = new Map<RegExp, IReqFileParser>();
    this.parsers.set(
      new RegExp(".*?requirements/.*?.txt"),
      new PythonReqFileParser()
    );
    this.parsers.set(
      new RegExp(".*?requirements.txt"),
      new PythonReqFileParser()
    );
    this.parsers.set(new RegExp(".*?package.json"), new NodeReqFileParser());

    //Set up credentials for GitHub API requests
    this.githubRequestParams = {
      headers: {
        Authorization: "token " + githubAuthToken(),
      },
    };
  }

  //GET /software?query=term : Returns all software in the CPE which match a search substring
  //Use: SoftwareSearchView
  getSoftwareRoute = async (req: express.Request, res: express.Response) => {
    let startAt = req.query.startAt as string;
    let pageSize = req.query.pageSize as string;
    let searchTerm = req.query.query as string;

    if (
      startAt === undefined ||
      pageSize === undefined ||
      searchTerm === undefined
    ) {
      res.status(400);
      res.send({
        error: "Request was missing either startAt, pageSize, or query params",
      });
      return;
    }

    let results = [] as any[];
    let start = parseInt(startAt);

    if(!useRealData()) {
      for (let i = start; i < start + parseInt(pageSize); i++) {
        let item = mockCPEResult;
        results.push(item);
      }
      res.send({ results: results, total: 999999 }); //TODO: Set total to actual total
      return;
    }

    
    let response : AxiosResponse<any>;

    //Set a delay (reduce rate limiting)
    //delay(requestSleepTime());

    response = await axios.get(`${nvdBaseURI()}/cpes/1.0?keyword=${searchTerm}&startIndex=${startAt}&resultsPerPage=${pageSize}`);
  
    let parsedResponse : any = JSON.parse(JSON.stringify(response.data));
    res.send({results:parsedResponse.result.cpes,total:parsedResponse.totalResults}); 
    
  };

  //GET /software/fromRepo/:username/:reponame
  //Gets a list of software dependencies from the target repo (if supported)
  getSoftwareByRepoRoute = async (
    req: express.Request,
    res: express.Response
  ) => {
    let repoName = req.params.repo;
    let user = req.params.user;

    //TODO: implement pagination
    let startAt = req.query.startAt as string;
    let pageSize = req.query.pageSize as string;

    if (startAt === undefined || pageSize === undefined) {
      res.status(400);
      res.send({
        error: "Request was missing either startAt or pageSize params",
      });
      return;
    }
    axios
      .get(
        githubBaseURI() + "/repos/" + user + "/" + repoName + "/commits",
        this.githubRequestParams
      )
      .then((commitRes) => {
        let commitResBody = commitRes.data;
        let treeSha = commitResBody[0]["commit"]["tree"]["sha"];

        //NOTE: May fail if recursion is too deep, add handling for pagination (?)
        axios
          .get(
            githubBaseURI +
              "/repos/" +
              user +
              "/" +
              repoName +
              "/git/trees/" +
              treeSha +
              "?recursive=true",
            this.githubRequestParams
          )
          .then((treeRes) => {
            let fileList = treeRes.data["tree"];

            Promise.all(
              fileList
                .filter((fileEntry: any) => {
                  let parsers = Array.from(this.parsers.keys()).filter(
                    (it: RegExp) => {
                      return fileEntry["path"].match(it);
                    }
                  );
                  return parsers.length > 0; //At least one matching parser exists
                })
                .map((fileEntry: any) => {
                  return new Promise((resolve, reject) => {
                    axios
                      .get(fileEntry.url, this.githubRequestParams)
                      .then((res) => {
                        resolve({ path: fileEntry.path, data: res.data });
                      })
                      .catch((err) => {
                        reject(err);
                      });
                  });
                })
            )
              .then((reqFiles: any[]) => {
                Promise.all(
                  reqFiles.map((fileEntry: any) => {
                    return new Promise((resolve, reject) => {
                      let fileName = fileEntry.path.split("/").pop();
                      let content = Buffer.from(
                        fileEntry.data.content,
                        "base64"
                      ).toString("utf-8");
                      resolve({
                        path: fileEntry.path,
                        fileName: fileName,
                        content: content,
                      });
                    });
                  })
                )
                  .then((reqFiles) => {
                    Promise.all(
                      reqFiles.map((fileEntry: any) => {
                        return new Promise((resolve, reject) => {
                          let fileName = fileEntry.fileName;
                          let path = fileEntry.path;
                          let parsers = Array.from(this.parsers.keys()).filter(
                            (it: RegExp) => {
                              return path.match(it);
                            }
                          );
                          if (parsers.length <= 0) {
                            reject("Could not find a parser for " + fileName);
                          } else {
                            let parser = this.parsers.get(parsers[0]); //Use first matching parser
                            if (parser === undefined) {
                              reject(
                                "Found a parser for " +
                                  fileName +
                                  ", but it's undefined somehow"
                              );
                            } else {
                              parser
                                .parseDependencies(fileEntry.content)
                                .then((dependencies) => {
                                  let dependencyObjs = dependencies.map(
                                    (it: IDependency) => { 
                                      return it.toSoftwareSearchResult(fileEntry.path) }
                                  );

                                  resolve(
                                    dependencyObjs
                                  );
                                });
                            }
                          }
                        });
                      })
                    )
                      .then((depFiles: any[]) => {
                        depFiles = depFiles.filter((it : any[]) => { return it.length > 0 });
                        let deps = depFiles.reduce((acc : any, it : any) => {
                          return acc.concat(it);
                        });
                        res.status(200).send({results:deps,total:deps.length});
                      })
                  })
              })
          })
      })
      .catch((err) => {
        res.status(400).send(err)});
  };
}

export default SoftwareRouter;
