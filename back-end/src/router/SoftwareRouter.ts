import express from "express";
import AbstractRouter from "./AbstractRouter";
import IRouter from "./IRouter";
import mockCPEResult from "../../test/mockCPEResult";
import axios from "axios";
import IReqFileParser from "../parser/IReqFileParser";
import PythonReqFileParser from "../parser/PythonReqFileParser";
import NodeReqFileParser from "../parser/NodeReqFileParser";
import IDependency from "../parser/IDependency";

class SoftwareRouter extends AbstractRouter implements IRouter {
  parsers: Map<RegExp, IReqFileParser>;
  githubAPIRootURI: string;
  reqParams : any;

  constructor(app: express.Application, route: string) {
    super(app, route);
    //TODO: update to add all routes
    this.router.get("/", this.getSoftwareRoute);
    this.router.get(
      "/fromRepo/:user/:repo",
      this.getSoftwareByRepoRoute
    );

    //Set up RegExp -> Parser mappings
    this.parsers = new Map<RegExp, IReqFileParser>();
    this.parsers.set(
      new RegExp(".*?requirements/.*?.txt"),
      new PythonReqFileParser()
    );
    this.parsers.set(
      new RegExp(".*?requirements.txt"),
      new PythonReqFileParser()
    );
    this.parsers.set(new RegExp(".*?package.json"), new NodeReqFileParser());

    //TODO: Move to env?
    this.githubAPIRootURI = "https://api.github.com";

    //TODO: move to env
    //This is a GitHub personal access token
    this.reqParams = {
      header: {
        Authorization: "Token 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", 
      }
    }
  }

  //GET /software?query=term : Returns all software in the CPE which match a search substring
  //Use: SoftwareSearchView
  getSoftwareRoute = async (req: express.Request, res: express.Response) => {
    let startAt = req.query.startAt as string;
    let pageSize = req.query.pageSize as string;
    let searchTerm = req.query.query as string;

    if (
      startAt === undefined ||
      pageSize === undefined ||
      searchTerm === undefined
    ) {
      res.status(400);
      res.send({
        error: "Request was missing either startAt, pageSize, or query params",
      });
      return;
    }

    let result = [] as any[];

    let results = [] as any[];
    let start = parseInt(startAt);

    for (let i = start; i < start + parseInt(pageSize); i++) {
      let item = mockCPEResult; //TODO: Replace with real data
      results.push(item);
    }
    res.send({ results: results, total: 999999 });
  };

  getSoftwareByRepoRoute = async (req: express.Request, res: express.Response) => {
    let repoName = req.params.repo;
    let user = req.params.user;
    
    //TODO: implement pagination
    let startAt = req.query.startAt as string;
    let pageSize = req.query.pageSize as string;

    if (
      startAt === undefined ||
      pageSize === undefined 
    ) {
      res.status(400);
      res.send({
        error: "Request was missing either startAt or pageSize params",
      });
      return;
    }
    axios
      .get(
        this.githubAPIRootURI + "/repos/" + user + "/" + repoName + "/commits",
        this.reqParams
      )
      .then((commitRes) => {
        let commitResBody = commitRes.data;
        let treeSha = commitResBody[0]["commit"]["tree"]["sha"];

        //NOTE: May fail if recursion is too deep, add handling for pagination (?)
        axios
          .get(
            this.githubAPIRootURI + "/repos/" +
              user +
              "/" +
              repoName +
              "/git/trees/" +
              treeSha +
              "?recursive=true",
            this.reqParams
          )
          .then((treeRes) => {
            let fileList = treeRes.data["tree"];

            Promise.all(
              fileList
                .filter((fileEntry: any) => {
                  let parsers = Array.from(this.parsers.keys()).filter(
                    (it: RegExp) => {
                      return fileEntry["path"].match(it);
                    }
                  );
                  return parsers.length > 0; //At least one matching parser exists
                })
                .map((fileEntry: any) => {
                  return new Promise((resolve, reject) => {
                    axios
                      .get(fileEntry.url, this.reqParams)
                      .then((res) => {
                        resolve({ path: fileEntry.path, data: res.data });
                      })
                      .catch((err) => {
                        reject(err);
                      });
                  });
                })
            )
              .then((reqFiles: any[]) => {
                Promise.all(
                  reqFiles.map((fileEntry: any) => {
                    return new Promise((resolve, reject) => {
                      let fileName = fileEntry.path.split("/").pop();
                      let content = Buffer.from(
                        fileEntry.data.content,
                        "base64"
                      ).toString("utf-8");
                      resolve({
                        path: fileEntry.path,
                        fileName: fileName,
                        content: content,
                      });
                    });
                  })
                )
                  .then((reqFiles) => {
                    Promise.all(
                      reqFiles.map((fileEntry: any) => {
                        return new Promise((resolve, reject) => {
                          let fileName = fileEntry.fileName;
                          let path = fileEntry.path;
                          let parsers = Array.from(this.parsers.keys()).filter(
                            (it: RegExp) => {
                              return path.match(it);
                            }
                          );
                          if (parsers.length <= 0) {
                            reject("Could not find a parser for " + fileName);
                          } else {
                            let parser = this.parsers.get(parsers[0]); //Use first matching parser
                            if (parser === undefined) {
                              reject(
                                "Found a parser for " +
                                  fileName +
                                  ", but it's undefined somehow"
                              );
                            } else {
                              parser
                                .parseDependencies(fileEntry.content)
                                .then((dependencies) => {
                                  let dependencyStrings = dependencies.map(
                                    (it: IDependency) => it.toString()
                                  );
                                  resolve({
                                    path: fileEntry.path,
                                    dependencies: dependencyStrings,
                                  });
                                });
                            }
                          }
                        });
                      })
                    )
                      .then((filesWithDependencies: any) => {
                        res.send(filesWithDependencies);
                      })
                      .catch((err) => console.log(err));
                  })
                  .catch((err) => console.log(err));
              })
              .catch((err) => console.log(err));
          })
          .catch((err) => console.log(err));
      })
      .catch((err) => console.log(err));
  };
}

export default SoftwareRouter;
