import express from "express";
import AbstractRouter from "./AbstractRouter";
import IRouter from "./IRouter";
import mockCVEResult from "../../test/mockCVEResult";
import { useRealData } from "../Settings";
import { IVulnerabilityManager, VulnerabilityManager, VulnerabilityResult } from "../manager/VulnerabilityManager";

class VulnerabilityRouter extends AbstractRouter implements IRouter {
    protected vulnerabilityManager: IVulnerabilityManager;
    private pageCache: { [key: string]: { [key: string]: any[] } } = {};

    constructor(app : express.Application, route : string) {
        super(app,route);
        this.router.get("/",this.getVulnerabilitiesRoute);
        this.vulnerabilityManager = new VulnerabilityManager();
    }

    //GET vulnerabilities/ : Get the n most recent vulnerabilities from NVD (or further in the list, if start/end specified)
    //Use: VulnerabilityListView
    getVulnerabilitiesRoute = async(req : express.Request, res : express.Response) => {
        if(req.query.startAt === undefined || req.query.pageSize === undefined) {
            res.status(400);
            return res.send({error:"Request was missing either startAt or pageSize params"});
        }
        
        let startAt = parseInt(req.query.startAt as string);
        let pageSize = parseInt(req.query.pageSize as string);

        //Use fake data override if not set 
        if(!useRealData()) {
            let results=[] as any[];
            let start = startAt;
    
            for(let i=start;i<start+pageSize;i++) {
                let item = mockCVEResult; 
                results.push(item);
            }

            res.send({results:results,total:999999})
            return;
        }

        let result: VulnerabilityResult;
        let sortFn = (a: any, b: any) => b["lastModifiedDate"] > a["lastModifiedDate"] ? 1 : -1;

        if (req.query.query) {
            let keyword;
            let keywords;
            keyword = req.query.query as string;
            keywords = keyword.split(" ");
            let results = [];
            let startAts = keywords.map(_ => 0);
            
            if (startAt > 0 && this.pageCache[keyword][startAt-pageSize]) {
                startAts = this.pageCache[keyword][startAt-pageSize];
            }

            
            for (let i = 0; i < keywords.length; i++) {
                // loop over keywords and send a request for each - don't await here
                // request full pageSize for each in case of failures
                results.push(this.vulnerabilityManager.getVulns(startAts[i], pageSize, keywords[i]));
            }
            
            // await all here before concatenating into one object
            results = await Promise.all(results);
            
            let itemsPerKeyword = results
                .filter(thisResult => thisResult.failed === false)
                .map(thisResult => thisResult.items)
                .map(items => items.sort(sortFn));
            
            const flattened = (arr: any[]) => [].concat(...arr);

            let mergedResult = flattened(itemsPerKeyword);
            mergedResult.sort(sortFn);

            if (mergedResult.length === 0) {
                return res.status(200).send({ results: [], total: 0 });
            } else if (mergedResult.length > pageSize) {
                let nextStartAts = startAts;
                let oldest = mergedResult[pageSize-1]["lastModifiedDate"];
    
                for (let i = 0; i < itemsPerKeyword.length; i++) {
                    let nextIndex = itemsPerKeyword[i].findIndex((item: any) => item["lastModifiedDate"] < oldest);
                    nextStartAts[i] += nextIndex === -1 ? pageSize : nextIndex;
                }
    
                this.pageCache[keyword] = this.pageCache[keyword] || {};
                this.pageCache[keyword][startAt] = nextStartAts;
            }

            result = {
                // only failed if all requests failed
                failed: results.every((thisResult) => thisResult.failed === true),
                // collect all items from results that did not fail
                items: mergedResult,
                // get the total of all totals
                total: results.map(thisResult => thisResult.total).reduce((acc, thisTotal) => thisTotal + acc),
            };
        } else {
            result = await this.vulnerabilityManager.getVulns(startAt, pageSize);
            result.items.sort(sortFn);
        }
        
        if (result.failed) {
            return res.status(400).send("CVE API request failed");
        }
        
        res.send({results: result.items.slice(0,pageSize), total: result.total}); 
    }
}

export default VulnerabilityRouter;