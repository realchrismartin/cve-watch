import { cacheInvalidationDelay, nvdBaseURI, requestSleepTime, vulnPubDateParam } from "../Settings";
import axios from "axios";
import delay from "delay";
import qs from "querystring";

export interface VulnerabilityResult {
    failed: boolean;
    items: any[];
    total: number;
}

export interface CacheValue {
    result: Promise<VulnerabilityResult>;
    time: number;
}

export interface IVulnerabilityManager {
    getVulns(startIndex: number, resultsPerPage: number, keyword?: string): Promise<VulnerabilityResult>;
}


export class VulnerabilityManager implements IVulnerabilityManager {
    private vulnCache: Map<string, CacheValue>;
    private lastReqTime: number = 0;

    constructor() {
        this.vulnCache = new Map();
        this.runCacheSweeper();
    }

    /* Every cacheInvalidationDelay() ms, delete any old cache items */
    private runCacheSweeper = () => {
        for (let key in this.vulnCache) {
            let value = this.vulnCache.get(key) as CacheValue;
            if (Date.now() - value.time > cacheInvalidationDelay()) {
                this.vulnCache.delete(key);
            }
        }
        
        setTimeout(this.runCacheSweeper, cacheInvalidationDelay());
    }

    /* Check cache for requested data from Vulnerability Router and return.
       If not cached, request from CVE API and add to cache, with query as key. */
    async getVulns(startIndex: number, resultsPerPage: number, keyword?: string): Promise<VulnerabilityResult> {
        let cacheKey = [startIndex, resultsPerPage, keyword].join("|");
        
        if (!this.vulnCache.has(cacheKey)) {
            let queryParts;
            if (keyword?.substr(0,3) === "cpe") {
                queryParts = {
                    startIndex,
                    resultsPerPage,
                    cpeMatchString: keyword,
                };
            } else {
                queryParts = {
                    startIndex,
                    resultsPerPage,
                    keyword,
                };
            }

            if (!keyword) {
                delete queryParts.keyword;
            }

            let query = qs.stringify(queryParts);
            let fetchPromise = this.fetchFromApi(query, cacheKey); // not await'ing on purpose
            let cacheVal = { result: fetchPromise, time: Date.now() };
            this.vulnCache.set(cacheKey, cacheVal);
        }


        return this.vulnCache.get(cacheKey)?.result as Promise<VulnerabilityResult>; // guaranteed to be set from above
    }
    
    /* Send request to CVE API, with rate limiting */
    private async fetchFromApi(query: string, cacheKey: string): Promise<VulnerabilityResult> {
        if (Date.now() - this.lastReqTime < requestSleepTime()) {
            await delay(requestSleepTime());
        }    
        
        this.lastReqTime = Date.now();

        let response = await axios.get(`${nvdBaseURI()}cves/1.0?${query}&pubStartDate=${vulnPubDateParam()}`);

        if (response.status === 200 && response.data?.result) {
            console.info(response)
            return {
                failed: false,
                items: response.data.result.CVE_Items,
                total: response.data.totalResults,
            };
        } else {
            console.error(response);
        }

        this.vulnCache.delete(cacheKey); // immediately delete from cache if API call failed

        return {
            failed: true,
            items: [],
            total: 0,
        };
    }
}